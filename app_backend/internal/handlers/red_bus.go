package handlers

import (
	"database/sql"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/yourorg/wayfindcl/internal/geometry"
	"github.com/yourorg/wayfindcl/internal/moovit"
)

// RedBusHandler maneja las solicitudes de rutas de buses Red
type RedBusHandler struct {
	scraper    *moovit.Scraper
	routeCache *RouteCache
}

// GeometryServiceAdapter adapta geometry.Service para moovit.GeometryService
type GeometryServiceAdapter struct {
	service *geometry.Service
}

func (g *GeometryServiceAdapter) GetWalkingRoute(fromLat, fromLon, toLat, toLon float64, detailed bool) (moovit.RouteGeometry, error) {
	route, err := g.service.GetWalkingRoute(fromLat, fromLon, toLat, toLon, detailed)
	if err != nil {
		return moovit.RouteGeometry{}, err
	}

	instructions := make([]string, 0)
	for _, segment := range route.SegmentGeometries {
		if len(segment.Instructions) > 0 {
			instructions = append(instructions, segment.Instructions...)
		}
	}

	return moovit.RouteGeometry{
		TotalDistance: route.TotalDistance,
		TotalDuration: route.TotalDuration,
		MainGeometry:  route.MainGeometry,
		Instructions:  instructions,
	}, nil
}

func (g *GeometryServiceAdapter) GetVehicleRoute(fromLat, fromLon, toLat, toLon float64) (moovit.RouteGeometry, error) {
	route, err := g.service.GetVehicleRoute(fromLat, fromLon, toLat, toLon)
	if err != nil {
		return moovit.RouteGeometry{}, err
	}

	instructions := make([]string, 0)
	for _, segment := range route.SegmentGeometries {
		if len(segment.Instructions) > 0 {
			instructions = append(instructions, segment.Instructions...)
		}
	}

	return moovit.RouteGeometry{
		TotalDistance: route.TotalDistance,
		TotalDuration: route.TotalDuration,
		MainGeometry:  route.MainGeometry,
		Instructions:  instructions,
	}, nil
}

// NewRedBusHandler crea una nueva instancia del handler
func NewRedBusHandler(db *sql.DB) *RedBusHandler {
	scraper := moovit.NewScraper()
	if db != nil {
		scraper.SetDB(db)
		log.Printf("‚úÖ RedBusHandler configurado con acceso a base de datos GTFS")
	} else {
		log.Printf("‚ö†Ô∏è  RedBusHandler creado sin base de datos - solo funcionar√° scraping Moovit")
	}

	// NOTA: El servicio de geometr√≠a se configurar√° despu√©s con ConfigureRedBusGeometry()
	// porque se inicializa despu√©s de que se crean los handlers

	// Crear cach√© de rutas: 15 minutos TTL, m√°ximo 100 rutas
	cache := NewRouteCache(15*time.Minute, 100)
	log.Printf("‚úÖ RouteCache inicializado (TTL: 15 min, max: 100 rutas)")

	return &RedBusHandler{
		scraper:    scraper,
		routeCache: cache,
	}
}

// ConfigureRedBusGeometry configura el servicio de geometr√≠a en el scraper existente
func (h *RedBusHandler) ConfigureRedBusGeometry(geometrySvc *geometry.Service) {
	if geometrySvc != nil {
		adapter := &GeometryServiceAdapter{service: geometrySvc}
		h.scraper.SetGeometryService(adapter)
		log.Printf("‚úÖ RedBusHandler configurado con servicio de geometr√≠a (GraphHopper)")
	} else {
		log.Printf("‚ö†Ô∏è  RedBusHandler sin servicio de geometr√≠a - usar√° l√≠neas rectas para caminatas")
	}
}

// GetRedBusRoute maneja GET /api/red/route/:routeNumber
// Obtiene informaci√≥n detallada de una ruta de bus Red espec√≠fica
func (h *RedBusHandler) GetRedBusRoute(c *fiber.Ctx) error {
	routeNumber := c.Params("routeNumber")

	if routeNumber == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "route number is required",
		})
	}

	log.Printf("Fetching Red bus route: %s", routeNumber)

	route, err := h.scraper.GetRedBusRoute(routeNumber)
	if err != nil {
		log.Printf("Error fetching route %s: %v", routeNumber, err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": fmt.Sprintf("error fetching route: %v", err),
		})
	}

	return c.JSON(route)
}

// GetRedBusItinerary maneja POST /api/red/itinerary
// Obtiene un itinerario completo usando buses Red desde Moovit
func (h *RedBusHandler) GetRedBusItinerary(c *fiber.Ctx) error {
	type ItineraryRequest struct {
		OriginLat float64 `json:"origin_lat"`
		OriginLon float64 `json:"origin_lon"`
		DestLat   float64 `json:"dest_lat"`
		DestLon   float64 `json:"dest_lon"`
	}

	var req ItineraryRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "invalid request format",
		})
	}

	// Validar coordenadas
	if req.OriginLat < -90 || req.OriginLat > 90 ||
		req.OriginLon < -180 || req.OriginLon > 180 ||
		req.DestLat < -90 || req.DestLat > 90 ||
		req.DestLon < -180 || req.DestLon > 180 {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "invalid coordinates",
		})
	}

	log.Printf("Fetching Red bus itinerary from (%.4f, %.4f) to (%.4f, %.4f)",
		req.OriginLat, req.OriginLon, req.DestLat, req.DestLon)

	// Intentar obtener del cach√© primero
	if cachedRoute, found := h.routeCache.Get(req.OriginLat, req.OriginLon, req.DestLat, req.DestLon); found {
		log.Printf("‚úÖ Retornando ruta desde cach√©")
		return c.JSON(cachedRoute)
	}

	log.Printf("üîÑ Ruta no en cach√©, calculando nueva ruta...")

	// Obtener m√∫ltiples opciones de rutas
	routeOptions, err := h.scraper.GetRouteItinerary(
		req.OriginLat,
		req.OriginLon,
		req.DestLat,
		req.DestLon,
	)
	if err != nil {
		log.Printf("Error fetching itinerary: %v", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": fmt.Sprintf("error fetching itinerary: %v", err),
		})
	}

	// Guardar en cach√© para futuras consultas
	h.routeCache.Set(req.OriginLat, req.OriginLon, req.DestLat, req.DestLon, routeOptions)

	// Retornar TODAS las opciones para que el usuario elija por voz en Flutter
	return c.JSON(routeOptions)
}

// GetRedBusItineraryOptions maneja POST /api/red/itinerary/options
// FASE 1: Obtiene opciones LIGERAS sin geometr√≠a para selecci√≥n por voz
func (h *RedBusHandler) GetRedBusItineraryOptions(c *fiber.Ctx) error {
	type ItineraryRequest struct {
		OriginLat float64 `json:"origin_lat"`
		OriginLon float64 `json:"origin_lon"`
		DestLat   float64 `json:"dest_lat"`
		DestLon   float64 `json:"dest_lon"`
	}

	var req ItineraryRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "invalid request format",
		})
	}

	// Validar coordenadas
	if req.OriginLat < -90 || req.OriginLat > 90 ||
		req.OriginLon < -180 || req.OriginLon > 180 ||
		req.DestLat < -90 || req.DestLat > 90 ||
		req.DestLon < -180 || req.DestLon > 180 {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "invalid coordinates",
		})
	}

	log.Printf("üöå FASE 1: Obteniendo opciones ligeras de (%.4f, %.4f) a (%.4f, %.4f)",
		req.OriginLat, req.OriginLon, req.DestLat, req.DestLon)

	// Obtener opciones LIGERAS (sin geometr√≠a)
	lightweightOptions, err := h.scraper.GetLightweightRouteOptions(
		req.OriginLat,
		req.OriginLon,
		req.DestLat,
		req.DestLon,
	)
	if err != nil {
		log.Printf("Error obteniendo opciones ligeras: %v", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": fmt.Sprintf("error obteniendo opciones: %v", err),
		})
	}

	log.Printf("‚úÖ Retornando %d opciones ligeras para selecci√≥n por voz", len(lightweightOptions.Options))

	// üìä RESUMEN DE OPCIONES DISPONIBLES
	if len(lightweightOptions.Options) > 0 {
		log.Printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
		log.Printf("‚ïë              OPCIONES DE RUTA DISPONIBLES (FASE 1)              ‚ïë")
		log.Printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£")
		for i, option := range lightweightOptions.Options {
			busesText := strings.Join(option.RouteNumbers, ", ")
			log.Printf("‚ïë Opci√≥n %d: Bus %s", i+1, busesText)
			log.Printf("‚ïë   ‚è±Ô∏è  Duraci√≥n: %d minutos", option.TotalDuration)
			if option.Transfers > 0 {
				log.Printf("‚ïë   üîÑ Transbordos: %d", option.Transfers)
			}
			if option.WalkingTime > 0 {
				log.Printf("‚ïë   üö∂ Caminata: %d minutos", option.WalkingTime)
			}
			log.Printf("‚ïë   üìù %s", option.Summary)
			if i < len(lightweightOptions.Options)-1 {
				log.Printf("‚ïü‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï¢")
			}
		}
		log.Printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n")
	}

	// Retornar opciones para que Flutter las lea por voz
	return c.JSON(lightweightOptions)
}

// GetRedBusItineraryDetail maneja POST /api/red/itinerary/detail
// FASE 2: Genera geometr√≠a completa DESPU√âS de que usuario selecciona por voz
func (h *RedBusHandler) GetRedBusItineraryDetail(c *fiber.Ctx) error {
	type DetailRequest struct {
		OriginLat           float64 `json:"origin_lat"`
		OriginLon           float64 `json:"origin_lon"`
		DestLat             float64 `json:"dest_lat"`
		DestLon             float64 `json:"dest_lon"`
		SelectedOptionIndex int     `json:"selected_option_index"`
	}

	var req DetailRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "invalid request format",
		})
	}

	// Validar coordenadas
	if req.OriginLat < -90 || req.OriginLat > 90 ||
		req.OriginLon < -180 || req.OriginLon > 180 ||
		req.DestLat < -90 || req.DestLat > 90 ||
		req.DestLon < -180 || req.DestLon > 180 {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "invalid coordinates",
		})
	}

	// Validar √≠ndice de opci√≥n
	if req.SelectedOptionIndex < 0 {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "selected_option_index must be >= 0",
		})
	}

	log.Printf("üöå FASE 2: Generando geometr√≠a detallada para opci√≥n %d", req.SelectedOptionIndex)

	// Generar geometr√≠a completa para la opci√≥n seleccionada
	detailedItinerary, err := h.scraper.GetDetailedItinerary(
		req.OriginLat,
		req.OriginLon,
		req.DestLat,
		req.DestLon,
		req.SelectedOptionIndex,
	)
	if err != nil {
		log.Printf("Error generando itinerario detallado: %v", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": fmt.Sprintf("error generando geometr√≠a: %v", err),
		})
	}

	log.Printf("‚úÖ Geometr√≠a detallada generada con %d legs", len(detailedItinerary.Legs))

	// ÔøΩ RESUMEN VISUAL DE LA RUTA (estilo Google Maps)
	log.Printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
	log.Printf("‚ïë                    RESUMEN DE RUTA GENERADA                      ‚ïë")
	log.Printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£")

	// Extraer informaci√≥n de los buses
	totalBusStops := 0
	busDuration := 0
	busRoutes := []string{}
	walkDuration := 0
	totalWalkDistance := 0.0

	for _, leg := range detailedItinerary.Legs {
		if leg.Type == "bus" {
			totalBusStops += len(leg.Stops)
			busDuration += leg.Duration
			if leg.RouteNumber != "" {
				busRoutes = append(busRoutes, leg.RouteNumber)
			}
		} else if leg.Type == "walk" {
			walkDuration += leg.Duration
			totalWalkDistance += leg.Distance
		}
	}

	log.Printf("‚ïë üöå Buses a tomar: %s", strings.Join(busRoutes, ", "))
	log.Printf("‚ïë üöè Total de paradas: %d paradas", totalBusStops)
	log.Printf("‚ïë ‚è±Ô∏è  Tiempo en bus: %d minutos", busDuration)
	log.Printf("‚ïë üö∂ Tiempo caminando: %d minutos (%.2f km)", walkDuration, totalWalkDistance)
	log.Printf("‚ïë ‚è∞ Duraci√≥n total: %d minutos", detailedItinerary.TotalDuration)
	log.Printf("‚ïë üìè Distancia total: %.2f km", detailedItinerary.TotalDistance)
	log.Printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n")

	// ÔøΩÔøΩ DEBUG: Mostrar datos que se env√≠an al frontend
	log.Printf("üîç [DEBUG-RESPONSE] ========== DATOS ENVIADOS AL FRONTEND ==========")
	log.Printf("üîç [DEBUG-RESPONSE] Total Legs: %d", len(detailedItinerary.Legs))
	log.Printf("üîç [DEBUG-RESPONSE] Duraci√≥n Total: %d min", detailedItinerary.TotalDuration)
	log.Printf("üîç [DEBUG-RESPONSE] Distancia Total: %.2f km", detailedItinerary.TotalDistance)
	log.Printf("üîç [DEBUG-RESPONSE] Rutas de Bus: %v", detailedItinerary.RedBusRoutes)

	for i, leg := range detailedItinerary.Legs {
		log.Printf("üîç [DEBUG-RESPONSE-LEG-%d] ----------------------", i+1)
		log.Printf("   Type: %s", leg.Type)
		log.Printf("   Mode: %s", leg.Mode)
		log.Printf("   RouteNumber: %s", leg.RouteNumber)
		log.Printf("   From: %s", leg.From)
		log.Printf("   To: %s", leg.To)
		log.Printf("   Duration: %d min", leg.Duration)
		log.Printf("   Distance: %.2f km", leg.Distance)
		log.Printf("   Geometry Points: %d", len(leg.Geometry))
		log.Printf("   StopCount: %d", leg.StopCount)
		log.Printf("   Total Stops in array: %d", len(leg.Stops))

		if len(leg.Geometry) > 0 {
			log.Printf("   Geometr√≠a - Primer punto: [%.6f, %.6f]", leg.Geometry[0][1], leg.Geometry[0][0])
			log.Printf("   Geometr√≠a - √öltimo punto: [%.6f, %.6f]",
				leg.Geometry[len(leg.Geometry)-1][1], leg.Geometry[len(leg.Geometry)-1][0])
		} else {
			log.Printf("   ‚ö†Ô∏è  SIN GEOMETR√çA EN ESTE LEG")
		}

		if leg.DepartStop != nil {
			log.Printf("   DepartStop: %s (%.6f, %.6f)",
				leg.DepartStop.Name, leg.DepartStop.Latitude, leg.DepartStop.Longitude)
		}

		if leg.ArriveStop != nil {
			log.Printf("   ArriveStop: %s (%.6f, %.6f)",
				leg.ArriveStop.Name, leg.ArriveStop.Latitude, leg.ArriveStop.Longitude)
		}

		if len(leg.Stops) > 0 {
			log.Printf("   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
			log.Printf("   ‚îÇ üöè PARADAS DE LA RUTA %s (%d paradas)", leg.RouteNumber, len(leg.Stops))
			log.Printf("   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")
			for j, stop := range leg.Stops {
				stopType := "   "
				if j == 0 {
					stopType = "üü¢" // Primera parada
				} else if j == len(leg.Stops)-1 {
					stopType = "üî¥" // √öltima parada
				} else {
					stopType = "‚ö™" // Parada intermedia
				}
				log.Printf("   ‚îÇ %s %2d. %-45s [%s]", stopType, j+1, stop.Name, stop.Code)
			}
			log.Printf("   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
		}
	}
	log.Printf("üîç [DEBUG-RESPONSE] ========== FIN DATOS ==========")

	return c.JSON(detailedItinerary)
}

// ListCommonRedRoutes maneja GET /api/red/routes/common
// Lista rutas Red comunes en Santiago
func (h *RedBusHandler) ListCommonRedRoutes(c *fiber.Ctx) error {
	commonRoutes := []fiber.Map{
		{
			"route_number": "506",
			"name":         "L√≠nea 506 - Alameda / Vicu√±a Mackenna",
			"description":  "Conecta el centro con Pe√±alol√©n",
			"zones":        []string{"Centro", "Providencia", "√ëu√±oa", "Pe√±alol√©n"},
		},
		{
			"route_number": "210",
			"name":         "L√≠nea 210 - Estaci√≥n Central / Providencia",
			"description":  "Ruta que conecta el poniente con el oriente",
			"zones":        []string{"Estaci√≥n Central", "Santiago", "Providencia"},
		},
		{
			"route_number": "405",
			"name":         "L√≠nea 405 - Independencia / Recoleta",
			"description":  "Servicio en el sector norte de Santiago",
			"zones":        []string{"Independencia", "Recoleta", "Conchal√≠"},
		},
		{
			"route_number": "427",
			"name":         "L√≠nea 427 - Maip√∫ / Pudahuel",
			"description":  "Conecta comunas del poniente",
			"zones":        []string{"Maip√∫", "Pudahuel", "Estaci√≥n Central"},
		},
		{
			"route_number": "516",
			"name":         "L√≠nea 516 - La Florida / Puente Alto",
			"description":  "Servicio en el sector sur-oriente",
			"zones":        []string{"La Florida", "Puente Alto", "San Jos√© de Maipo"},
		},
	}

	return c.JSON(fiber.Map{
		"total":  len(commonRoutes),
		"routes": commonRoutes,
	})
}

// SearchRedRoutes maneja GET /api/red/routes/search?q=query
// Busca rutas Red por nombre o zona
func (h *RedBusHandler) SearchRedRoutes(c *fiber.Ctx) error {
	query := c.Query("q")

	if query == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "search query is required",
		})
	}

	// En producci√≥n, esto deber√≠a buscar en una base de datos
	// Por ahora, retornamos resultados de ejemplo
	results := []fiber.Map{
		{
			"route_number": "506",
			"name":         "L√≠nea 506",
			"relevance":    0.95,
		},
	}

	return c.JSON(fiber.Map{
		"query":   query,
		"total":   len(results),
		"results": results,
	})
}

// GetRedBusStops maneja GET /api/red/route/:routeNumber/stops
// Obtiene todas las paradas de una ruta Red espec√≠fica
func (h *RedBusHandler) GetRedBusStops(c *fiber.Ctx) error {
	routeNumber := c.Params("routeNumber")

	if routeNumber == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "route number is required",
		})
	}

	route, err := h.scraper.GetRedBusRoute(routeNumber)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": fmt.Sprintf("error fetching route: %v", err),
		})
	}

	return c.JSON(fiber.Map{
		"route_number": routeNumber,
		"route_name":   route.RouteName,
		"total_stops":  len(route.Stops),
		"stops":        route.Stops,
	})
}

// GetCacheStats maneja GET /api/red/cache/stats
// Devuelve estad√≠sticas del cach√© de rutas
func (h *RedBusHandler) GetCacheStats(c *fiber.Ctx) error {
	stats := h.routeCache.Stats()
	return c.JSON(fiber.Map{
		"status": "ok",
		"cache":  stats,
	})
}

// ClearCache maneja POST /api/red/cache/clear
// Limpia todo el cach√© de rutas
func (h *RedBusHandler) ClearCache(c *fiber.Ctx) error {
	h.routeCache.Clear()
	return c.JSON(fiber.Map{
		"status":  "ok",
		"message": "Cache cleared successfully",
	})
}

// GetRedBusGeometry maneja GET /api/red/route/:routeNumber/geometry
// Obtiene la geometr√≠a (polil√≠nea) de una ruta Red para visualizaci√≥n en mapa
func (h *RedBusHandler) GetRedBusGeometry(c *fiber.Ctx) error {
	routeNumber := c.Params("routeNumber")

	if routeNumber == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "route number is required",
		})
	}

	route, err := h.scraper.GetRedBusRoute(routeNumber)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": fmt.Sprintf("error fetching route: %v", err),
		})
	}

	return c.JSON(fiber.Map{
		"route_number": routeNumber,
		"type":         "LineString",
		"coordinates":  route.Geometry,
		"properties": fiber.Map{
			"name":         route.RouteName,
			"color":        "#E30613", // Color rojo caracter√≠stico de buses Red
			"stroke_width": 4,
			"stops_count":  len(route.Stops),
		},
	})
}
