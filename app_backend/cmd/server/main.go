package main

import (
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/logger"
	"github.com/joho/godotenv"

	appdb "github.com/yourorg/wayfindcl/internal/db"
	"github.com/yourorg/wayfindcl/internal/debug"
	"github.com/yourorg/wayfindcl/internal/geometry"
	"github.com/yourorg/wayfindcl/internal/graphhopper"
	"github.com/yourorg/wayfindcl/internal/handlers"
	"github.com/yourorg/wayfindcl/internal/routes"
)

func main() {
	_ = godotenv.Load()

	app := fiber.New(fiber.Config{
		ReadTimeout:  180 * time.Second, // 3 minutos para operaciones muy lentas como scraping
		WriteTimeout: 180 * time.Second, // 3 minutos para respuestas grandes
		IdleTimeout:  240 * time.Second, // 4 minutos de timeout idle
	})
	app.Use(logger.New())

	// ============================================================================
	// INICIAR GRAPHHOPPER COMO SUBPROCESO
	// ============================================================================
	log.Println("Iniciando GraphHopper...")
	if err := handlers.InitGraphHopper(); err != nil {
		log.Printf("‚ö†Ô∏è  GraphHopper no pudo iniciarse: %v", err)
		log.Println("   El servidor continuar√° pero routing puede fallar")
	} else {
		log.Println("‚úÖ GraphHopper iniciado correctamente")
	}

	// ============================================================================
	// DB CONNECTION
	// ============================================================================
	var dbReady bool

	go func() {
		for {
			db, err := appdb.Connect()
			if err != nil {
				log.Printf("db connect error: %v (retrying in 5s)", err)
				time.Sleep(5 * time.Second)
				continue
			}
			if err := appdb.EnsureSchema(db); err != nil {
				log.Printf("ensure schema error: %v (retrying in 5s)", err)
				time.Sleep(5 * time.Second)
				continue
			}
			handlers.Setup(db)
			routes.Register(app, db)
			dbReady = true
			log.Printf("‚úÖ Database ready and routes registered")

			// ================================================================
			// INICIALIZAR DEBUG DASHBOARD (si est√° habilitado)
			// ================================================================
			if debug.IsEnabled() {
				debug.LogInfo("üöÄ Backend iniciado correctamente", map[string]interface{}{
					"timestamp": time.Now().Format(time.RFC3339),
					"database":  "conectada",
					"routes":    "registradas",
				})
				log.Println("‚úÖ Debug Dashboard iniciado - enviando datos a dashboard")
			}

			// ================================================================
			// INICIALIZAR SERVICIO DE GEOMETR√çA (despu√©s de DB)
			// ================================================================
			ghClient := graphhopper.NewClient()

			// Esperar a que GraphHopper est√© listo
			log.Println("üîó Conectando servicio de geometr√≠a con GraphHopper...")
			for i := 0; i < 30; i++ {
				if ghClient.HealthCheck() == nil {
					break
				}
				time.Sleep(1 * time.Second)
			}

			// Crear servicio de geometr√≠a (integra GTFS + GraphHopper)
			geometrySvc := geometry.NewService(db, ghClient)
			handlers.InitGeometryService(geometrySvc)

			// Configurar servicio de geometr√≠a en RedBusHandler para rutas a pie con GraphHopper
			routes.ConfigureRedBusGeometry(geometrySvc)

			log.Println("‚úÖ Servicio de Geometr√≠a inicializado (GTFS + GraphHopper)")
			log.Println("‚úÖ RedBusHandler configurado para usar GraphHopper en caminatas")

			// ================================================================
			// ENVIAR ESTADO COMPLETO AL DEBUG DASHBOARD
			// ================================================================
			if debug.IsEnabled() {
				debug.LogInfo("üó∫Ô∏è GraphHopper conectado", map[string]interface{}{
					"status": "ready",
					"health": "ok",
				})

				debug.LogInfo("üìê Servicio de Geometr√≠a listo", map[string]interface{}{
					"gtfs":       "integrado",
					"graphhopper": "activo",
					"walking":    "disponible",
				})

				// Enviar m√©tricas iniciales
				debug.UpdateMetrics(15.5, 512, 0, 0)

				// Enviar estado de APIs
				debug.UpdateApiStatus("online", "online", "connected", 45.2, 5, 20, "v1.0.0")

				log.Println("üìä Datos iniciales enviados al dashboard")
			}

			return
		}
	}()

	// Wait briefly for DB to be ready
	for i := 0; i < 10 && !dbReady; i++ {
		time.Sleep(500 * time.Millisecond)
	}

	// Enviar log cuando el servidor est√© completamente listo
	if debug.IsEnabled() {
		debug.LogInfo("‚úÖ Sistema completamente listo", map[string]interface{}{
			"port":     os.Getenv("PORT"),
			"endpoints": 15,
		})
	}

	// ============================================================================
	// GRACEFUL SHUTDOWN - Detener GraphHopper al cerrar backend
	// ============================================================================
	// Capturar se√±ales de terminaci√≥n (Ctrl+C, kill, etc.)
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	go func() {
		<-sigChan
		log.Println("\nüõë Se√±al de terminaci√≥n recibida, cerrando servidor...")

		// Detener GraphHopper
		log.Println("üõë Deteniendo GraphHopper...")
		if err := graphhopper.StopGraphHopperProcess(); err != nil {
			log.Printf("‚ö†Ô∏è  Error deteniendo GraphHopper: %v", err)
		}

		// Cerrar servidor Fiber
		if err := app.Shutdown(); err != nil {
			log.Printf("‚ö†Ô∏è  Error cerrando servidor: %v", err)
		}

		log.Println("‚úÖ Servidor cerrado correctamente")
		os.Exit(0)
	}()

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	log.Printf("üöÄ Servidor escuchando en :%s", port)
	log.Println("üìç Endpoints disponibles:")
	log.Println("   ‚ïê‚ïê‚ïê GEOMETR√çA CENTRALIZADA (NUEVO) ‚ïê‚ïê‚ïê")
	log.Println("   GET  /api/geometry/walking          - Geometr√≠a peatonal")
	log.Println("   GET  /api/geometry/driving          - Geometr√≠a vehicular")
	log.Println("   POST /api/geometry/transit          - Geometr√≠a transporte p√∫blico")
	log.Println("   GET  /api/geometry/stops/nearby     - Paradas cercanas (distancia real)")
	log.Println("   POST /api/geometry/batch/walking-times - Batch: tiempos m√∫ltiples destinos")
	log.Println("   GET  /api/geometry/isochrone        - √Årea alcanzable en X minutos")
	log.Println("")
	log.Println("   ‚ïê‚ïê‚ïê ROUTING (LEGACY - Compatibilidad) ‚ïê‚ïê‚ïê")
	log.Println("   GET  /api/route/walking             - Rutas peatonales")
	log.Println("   POST /api/route/transit             - Transporte p√∫blico")
	log.Println("   POST /api/route/options             - Opciones de ruta")
	log.Println("")
	log.Println("üí° Presiona Ctrl+C para detener")
	log.Println("üí° Todos los c√°lculos geom√©tricos centralizados en /api/geometry/*")

	if err := app.Listen(":" + port); err != nil {
		log.Fatal(err)
	}
}
